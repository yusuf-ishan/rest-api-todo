{"version":3,"file":"signals.module.js","sources":["../runtime/src/index.ts","../runtime/src/auto.ts","../src/index.ts"],"sourcesContent":["import { signal, computed, effect, Signal } from \"@preact/signals-core\";\nimport { useRef, useMemo, useEffect } from \"react\";\nimport { useSyncExternalStore } from \"use-sync-external-store/shim/index.js\";\n\nexport { installAutoSignalTracking } from \"./auto\";\n\nconst Empty = [] as const;\nconst ReactElemType = Symbol.for(\"react.element\"); // https://github.com/facebook/react/blob/346c7d4c43a0717302d446da9e7423a8e28d8996/packages/shared/ReactSymbols.js#L15\n\nexport function wrapJsx<T>(jsx: T): T {\n\tif (typeof jsx !== \"function\") return jsx;\n\n\treturn function (type: any, props: any, ...rest: any[]) {\n\t\tif (typeof type === \"string\" && props) {\n\t\t\tfor (let i in props) {\n\t\t\t\tlet v = props[i];\n\t\t\t\tif (i !== \"children\" && v instanceof Signal) {\n\t\t\t\t\tprops[i] = v.value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jsx.call(jsx, type, props, ...rest);\n\t} as any as T;\n}\n\nconst symDispose: unique symbol = (Symbol as any).dispose || Symbol.for(\"Symbol.dispose\");\n\ninterface Effect {\n\t_sources: object | undefined;\n\t_start(): () => void;\n\t_callback(): void;\n\t_dispose(): void;\n}\n\nexport interface EffectStore {\n\teffect: Effect;\n\tsubscribe(onStoreChange: () => void): () => void;\n\tgetSnapshot(): number;\n\t/** finishEffect - stop tracking the signals used in this component */\n\tf(): void;\n\t[symDispose](): void;\n}\n\nlet finishUpdate: (() => void) | undefined;\n\nfunction setCurrentStore(store?: EffectStore) {\n\t// end tracking for the current update:\n\tif (finishUpdate) finishUpdate();\n\t// start tracking the new update:\n\tfinishUpdate = store && store.effect._start();\n}\n\nconst clearCurrentStore = () => setCurrentStore();\n\n/**\n * A redux-like store whose store value is a positive 32bit integer (a 'version').\n *\n * React subscribes to this store and gets a snapshot of the current 'version',\n * whenever the 'version' changes, we tell React it's time to update the component (call 'onStoreChange').\n *\n * How we achieve this is by creating a binding with an 'effect', when the `effect._callback' is called,\n * we update our store version and tell React to re-render the component ([1] We don't really care when/how React does it).\n *\n * [1]\n * @see https://react.dev/reference/react/useSyncExternalStore\n * @see https://github.com/reactjs/rfcs/blob/main/text/0214-use-sync-external-store.md\n */\nfunction createEffectStore(): EffectStore {\n\tlet effectInstance!: Effect;\n\tlet version = 0;\n\tlet onChangeNotifyReact: (() => void) | undefined;\n\n\tlet unsubscribe = effect(function (this: Effect) {\n\t\teffectInstance = this;\n\t});\n\teffectInstance._callback = function () {\n\t\tversion = (version + 1) | 0;\n\t\tif (onChangeNotifyReact) onChangeNotifyReact();\n\t};\n\n\treturn {\n\t\teffect: effectInstance,\n\t\tsubscribe(onStoreChange) {\n\t\t\tonChangeNotifyReact = onStoreChange;\n\n\t\t\treturn function () {\n\t\t\t\t/**\n\t\t\t\t * Rotate to next version when unsubscribing to ensure that components are re-run\n\t\t\t\t * when subscribing again.\n\t\t\t\t *\n\t\t\t\t * In StrictMode, 'memo'-ed components seem to keep a stale snapshot version, so\n\t\t\t\t * don't re-run after subscribing again if the version is the same as last time.\n\t\t\t\t *\n\t\t\t\t * Because we unsubscribe from the effect, the version may not change. We simply\n\t\t\t\t * set a new initial version in case of stale snapshots here.\n\t\t\t\t */\n\t\t\t\tversion = (version + 1) | 0;\n\t\t\t\tonChangeNotifyReact = undefined;\n\t\t\t\tunsubscribe();\n\t\t\t};\n\t\t},\n\t\tgetSnapshot() {\n\t\t\treturn version;\n\t\t},\n\t\tf() {\n\t\t\tclearCurrentStore();\n\t\t},\n\t\t[symDispose]() {\n\t\t\tclearCurrentStore();\n\t\t}\n\t};\n}\n\nlet finalCleanup: Promise<void> | undefined;\nconst _queueMicroTask = Promise.prototype.then.bind(Promise.resolve());\n\n/**\n * Custom hook to create the effect to track signals used during render and\n * subscribe to changes to rerender the component when the signals change.\n */\nexport function useSignals(): EffectStore {\n\tclearCurrentStore();\n\tif (!finalCleanup) {\n\t\tfinalCleanup = _queueMicroTask(() => {\n\t\t\tfinalCleanup = undefined;\n\t\t\tclearCurrentStore();\n\t\t});\n\t}\n\n\tconst storeRef = useRef<EffectStore>();\n\tif (storeRef.current == null) {\n\t\tstoreRef.current = createEffectStore();\n\t}\n\n\tconst store = storeRef.current;\n\tuseSyncExternalStore(store.subscribe, store.getSnapshot, store.getSnapshot);\n\tsetCurrentStore(store);\n\n\treturn store;\n}\n\n/**\n * A wrapper component that renders a Signal's value directly as a Text node or JSX.\n */\nfunction SignalValue({ data }: { data: Signal }) {\n\treturn data.value;\n}\n\n// Decorate Signals so React renders them as <SignalValue> components.\nObject.defineProperties(Signal.prototype, {\n\t$$typeof: { configurable: true, value: ReactElemType },\n\ttype: { configurable: true, value: SignalValue },\n\tprops: {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn { data: this };\n\t\t},\n\t},\n\tref: { configurable: true, value: null },\n});\n\nexport function useSignal<T>(value: T) {\n\treturn useMemo(() => signal<T>(value), Empty);\n}\n\nexport function useComputed<T>(compute: () => T) {\n\tconst $compute = useRef(compute);\n\t$compute.current = compute;\n\treturn useMemo(() => computed<T>(() => $compute.current()), Empty);\n}\n\nexport function useSignalEffect(cb: () => void | (() => void)) {\n\tconst callback = useRef(cb);\n\tcallback.current = cb;\n\n\tuseEffect(() => {\n\t\treturn effect(() => callback.current());\n\t}, Empty);\n}\n","import {\n\t// @ts-ignore-next-line\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED as ReactInternals,\n} from \"react\";\nimport React from \"react\";\nimport jsxRuntime from \"react/jsx-runtime\";\nimport jsxRuntimeDev from \"react/jsx-dev-runtime\";\nimport { EffectStore, useSignals, wrapJsx } from \"./index\";\n\nexport interface ReactDispatcher {\n\tuseRef: typeof React.useRef;\n\tuseCallback: typeof React.useCallback;\n\tuseReducer: typeof React.useReducer;\n\tuseSyncExternalStore: typeof React.useSyncExternalStore;\n\tuseEffect: typeof React.useEffect;\n\tuseImperativeHandle: typeof React.useImperativeHandle;\n}\n\n// In order for signals to work in React, we need to observe what signals a\n// component uses while rendering. To do this, we need to know when a component\n// is rendering. To do this, we watch the transition of the\n// ReactCurrentDispatcher to know when a component is rerendering.\n//\n// To track when we are entering and exiting a component render (i.e. before and\n// after React renders a component), we track how the dispatcher changes.\n// Outside of a component rendering, the dispatcher is set to an instance that\n// errors or warns when any hooks are called. This behavior is prevents hooks\n// from being used outside of components. Right before React renders a\n// component, the dispatcher is set to an instance that doesn't warn or error\n// and contains the implementations of all hooks. Right after React finishes\n// rendering a component, the dispatcher is set to the erroring one again. This\n// erroring dispatcher is called the `ContextOnlyDispatcher` in React's source.\n//\n// So, we watch the getter and setter on `ReactCurrentDispatcher.current` to\n// monitor the changes to the current ReactDispatcher. When the dispatcher\n// changes from the ContextOnlyDispatcher to a \"valid\" dispatcher, we assume we\n// are entering a component render. At this point, we setup our\n// auto-subscriptions for any signals used in the component. We do this by\n// creating an Signal effect and manually starting the Signal effect. We use\n// `useSyncExternalStore` to trigger rerenders on the component when any signals\n// it uses changes.\n//\n// When the dispatcher changes from a valid dispatcher back to the\n// ContextOnlyDispatcher, we assume we are exiting a component render. At this\n// point we stop the effect.\n//\n// Some additional complexities to be aware of:\n// - If a component calls `setState` while rendering, React will re-render the\n//   component immediately. Before triggering the re-render, React will change\n//   the dispatcher to the HooksDispatcherOnRerender. When we transition to this\n//   rerendering adapter, we need to re-trigger our hooks to keep the order of\n//   hooks the same for every render of a component.\n//\n// - In development, useReducer, useState, and useMemo change the dispatcher to\n//   a different warning dispatcher (not ContextOnlyDispatcher) before invoking\n//   the reducer and resets it right after.\n//\n//   The useSyncExternalStore shim will use some of these hooks when we invoke\n//   it while entering a component render. We need to prevent this dispatcher\n//   change caused by these hooks from re-triggering our entering logic (it\n//   would cause an infinite loop if we did not). We do this by using a lock to\n//   prevent the setter from running while we are in the setter.\n//\n//   When a Component's function body invokes useReducer, useState, or useMemo,\n//   this change in dispatcher should not signal that we are entering or exiting\n//   a component render. We ignore this change by detecting these dispatchers as\n//   different from ContextOnlyDispatcher and other valid dispatchers.\n//\n// - The `use` hook will change the dispatcher to from a valid update dispatcher\n//   to a valid mount dispatcher in some cases. Similarly to useReducer\n//   mentioned above, we should not signal that we are exiting a component\n//   during this change. Because these other valid dispatchers do not pass the\n//   ContextOnlyDispatcher check, they do not affect our logic.\n//\n// - When server rendering, React does not change the dispatcher before and\n//   after each component render. It sets it once for before the first render\n//   and once for after the last render. This means that we will not be able to\n//   detect when we are entering or exiting a component render. This is fine\n//   because we don't need to detect this for server rendering. A component\n//   can't trigger async rerenders in SSR so we don't need to track signals.\n//\n//   If a component updates a signal value while rendering during SSR, we will\n//   not rerender the component because the signal value will synchronously\n//   change so all reads of the signal further down the tree will see the new\n//   value.\n\n/*\nBelow is a state machine definition for transitions between the various\ndispatchers in React's prod build. (It does not include dev time warning\ndispatchers which are just always ignored).\n\nENTER and EXIT suffixes indicates whether this ReactCurrentDispatcher transition\nsignals we are entering or exiting a component render, or if it doesn't signal a\nchange in the component rendering lifecyle (NOOP).\n\n```js\n// Paste this into https://stately.ai/viz to visualize the state machine.\nimport { createMachine } from \"xstate\";\n\n// ENTER, EXIT, NOOP suffixes indicates whether this ReactCurrentDispatcher\n// transition signals we are entering or exiting a component render, or\n// if it doesn't signal a change in the component rendering lifecyle (NOOP).\n\nconst dispatcherMachinePROD = createMachine({\n\tid: \"ReactCurrentDispatcher_PROD\",\n\tinitial: \"null\",\n\tstates: {\n\t\tnull: {\n\t\t\ton: {\n\t\t\t\tpushDispatcher: \"ContextOnlyDispatcher\",\n\t\t\t},\n\t\t},\n\t\tContextOnlyDispatcher: {\n\t\t\ton: {\n\t\t\t\trenderWithHooks_Mount_ENTER: \"HooksDispatcherOnMount\",\n\t\t\t\trenderWithHooks_Update_ENTER: \"HooksDispatcherOnUpdate\",\n\t\t\t\tpushDispatcher_NOOP: \"ContextOnlyDispatcher\",\n\t\t\t\tpopDispatcher_NOOP: \"ContextOnlyDispatcher\",\n\t\t\t},\n\t\t},\n\t\tHooksDispatcherOnMount: {\n\t\t\ton: {\n\t\t\t\trenderWithHooksAgain_ENTER: \"HooksDispatcherOnRerender\",\n\t\t\t\tresetHooksAfterThrow_EXIT: \"ContextOnlyDispatcher\",\n\t\t\t\tfinishRenderingHooks_EXIT: \"ContextOnlyDispatcher\",\n\t\t\t},\n\t\t},\n\t\tHooksDispatcherOnUpdate: {\n\t\t\ton: {\n\t\t\t\trenderWithHooksAgain_ENTER: \"HooksDispatcherOnRerender\",\n\t\t\t\tresetHooksAfterThrow_EXIT: \"ContextOnlyDispatcher\",\n\t\t\t\tfinishRenderingHooks_EXIT: \"ContextOnlyDispatcher\",\n\t\t\t\tuse_ResumeSuspensedMount_NOOP: \"HooksDispatcherOnMount\",\n\t\t\t},\n\t\t},\n\t\tHooksDispatcherOnRerender: {\n\t\t\ton: {\n\t\t\t\trenderWithHooksAgain_ENTER: \"HooksDispatcherOnRerender\",\n\t\t\t\tresetHooksAfterThrow_EXIT: \"ContextOnlyDispatcher\",\n\t\t\t\tfinishRenderingHooks_EXIT: \"ContextOnlyDispatcher\",\n\t\t\t},\n\t\t},\n\t},\n});\n```\n*/\n\nlet store: EffectStore | null = null;\nlet lock = false;\nlet currentDispatcher: ReactDispatcher | null = null;\n\nfunction installCurrentDispatcherHook() {\n\tObject.defineProperty(ReactInternals.ReactCurrentDispatcher, \"current\", {\n\t\tget() {\n\t\t\treturn currentDispatcher;\n\t\t},\n\t\tset(nextDispatcher: ReactDispatcher) {\n\t\t\tif (lock) {\n\t\t\t\tcurrentDispatcher = nextDispatcher;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst currentDispatcherType = getDispatcherType(currentDispatcher);\n\t\t\tconst nextDispatcherType = getDispatcherType(nextDispatcher);\n\n\t\t\t// Update the current dispatcher now so the hooks inside of the\n\t\t\t// useSyncExternalStore shim get the right dispatcher.\n\t\t\tcurrentDispatcher = nextDispatcher;\n\t\t\tif (\n\t\t\t\tisEnteringComponentRender(currentDispatcherType, nextDispatcherType)\n\t\t\t) {\n\t\t\t\tlock = true;\n\t\t\t\tstore = useSignals();\n\t\t\t\tlock = false;\n\t\t\t} else if (\n\t\t\t\tisExitingComponentRender(currentDispatcherType, nextDispatcherType)\n\t\t\t) {\n\t\t\t\tstore?.f();\n\t\t\t\tstore = null;\n\t\t\t}\n\t\t},\n\t});\n}\n\ntype DispatcherType = number;\nconst ContextOnlyDispatcherType = 1 << 0;\nconst WarningDispatcherType = 1 << 1;\nconst MountDispatcherType = 1 << 2;\nconst UpdateDispatcherType = 1 << 3;\nconst RerenderDispatcherType = 1 << 4;\nconst ServerDispatcherType = 1 << 5;\nconst BrowserClientDispatcherType =\n\tMountDispatcherType | UpdateDispatcherType | RerenderDispatcherType;\n\nconst dispatcherTypeCache = new Map<ReactDispatcher, DispatcherType>();\nfunction getDispatcherType(dispatcher: ReactDispatcher | null): DispatcherType {\n\t// Treat null the same as the ContextOnlyDispatcher.\n\tif (!dispatcher) return ContextOnlyDispatcherType;\n\n\tconst cached = dispatcherTypeCache.get(dispatcher);\n\tif (cached !== undefined) return cached;\n\n\t// The ContextOnlyDispatcher sets all the hook implementations to a function\n\t// that takes no arguments and throws and error. This dispatcher is the only\n\t// dispatcher where useReducer and useEffect will have the same\n\t// implementation.\n\tlet type: DispatcherType;\n\tconst useCallbackImpl = dispatcher.useCallback.toString();\n\tif (dispatcher.useReducer === dispatcher.useEffect) {\n\t\ttype = ContextOnlyDispatcherType;\n\n\t\t// @ts-expect-error When server rendering, useEffect and useImperativeHandle\n\t\t// are both set to noop functions and so have the same implementation.\n\t} else if (dispatcher.useEffect === dispatcher.useImperativeHandle) {\n\t\ttype = ServerDispatcherType;\n\t} else if (/Invalid/.test(useCallbackImpl)) {\n\t\t// We first check for warning dispatchers because they would also pass some\n\t\t// of the checks below.\n\t\ttype = WarningDispatcherType;\n\t} else if (\n\t\t// The development mount dispatcher invokes a function called\n\t\t// `mountCallback` whereas the development update/re-render dispatcher\n\t\t// invokes a function called `updateCallback`. Use that difference to\n\t\t// determine if we are in a mount or update-like dispatcher in development.\n\t\t// The production mount dispatcher defines an array of the form [callback,\n\t\t// deps] whereas update/re-render dispatchers read the array using array\n\t\t// indices (e.g. `[0]` and `[1]`). Use those differences to determine if we\n\t\t// are in a mount or update-like dispatcher in production.\n\t\t/updateCallback/.test(useCallbackImpl) ||\n\t\t(/\\[0\\]/.test(useCallbackImpl) && /\\[1\\]/.test(useCallbackImpl))\n\t) {\n\t\t// The update and rerender dispatchers have different implementations for\n\t\t// useReducer. We'll check it's implementation to determine if this is the\n\t\t// rerender or update dispatcher.\n\t\tlet useReducerImpl = dispatcher.useReducer.toString();\n\t\tif (\n\t\t\t// The development rerender dispatcher invokes a function called\n\t\t\t// `rerenderReducer` whereas the update dispatcher invokes a function\n\t\t\t// called `updateReducer`. The production rerender dispatcher returns an\n\t\t\t// array of the form `[state, dispatch]` whereas the update dispatcher\n\t\t\t// returns an array of `[fiber.memoizedState, dispatch]` so we check the\n\t\t\t// return statement in the implementation of useReducer to differentiate\n\t\t\t// between the two.\n\t\t\t/rerenderReducer/.test(useReducerImpl) ||\n\t\t\t/return\\s*\\[\\w+,/.test(useReducerImpl)\n\t\t) {\n\t\t\ttype = RerenderDispatcherType;\n\t\t} else {\n\t\t\ttype = UpdateDispatcherType;\n\t\t}\n\t} else {\n\t\ttype = MountDispatcherType;\n\t}\n\n\tdispatcherTypeCache.set(dispatcher, type);\n\treturn type;\n}\n\nfunction isEnteringComponentRender(\n\tcurrentDispatcherType: DispatcherType,\n\tnextDispatcherType: DispatcherType\n): boolean {\n\tif (\n\t\tcurrentDispatcherType & ContextOnlyDispatcherType &&\n\t\tnextDispatcherType & BrowserClientDispatcherType\n\t) {\n\t\t// ## Mount or update (ContextOnlyDispatcher -> ValidDispatcher (Mount or Update))\n\t\t//\n\t\t// If the current dispatcher is the ContextOnlyDispatcher and the next\n\t\t// dispatcher is a valid dispatcher, we are entering a component render.\n\t\treturn true;\n\t} else if (\n\t\tcurrentDispatcherType & WarningDispatcherType ||\n\t\tnextDispatcherType & WarningDispatcherType\n\t) {\n\t\t// ## Warning dispatcher\n\t\t//\n\t\t// If the current dispatcher or next dispatcher is an warning dispatcher,\n\t\t// we are not entering a component render. The current warning dispatchers\n\t\t// are used to warn when hooks are nested improperly and do not indicate\n\t\t// entering a new component render.\n\t\treturn false;\n\t} else if (nextDispatcherType & RerenderDispatcherType) {\n\t\t// Any transition into the rerender dispatcher is the beginning of a\n\t\t// component render, so we should invoke our hooks. Details below.\n\t\t//\n\t\t// ## In-place rerendering (e.g. Mount -> Rerender)\n\t\t//\n\t\t// If we are transitioning from the mount, update, or rerender dispatcher to\n\t\t// the rerender dispatcher (e.g. HooksDispatcherOnMount to\n\t\t// HooksDispatcherOnRerender), then this component is rerendering due to\n\t\t// calling setState inside of its function body. We are re-entering a\n\t\t// component's render method and so we should re-invoke our hooks.\n\t\treturn true;\n\t} else {\n\t\t// ## Resuming suspended mount edge case (Update -> Mount)\n\t\t//\n\t\t// If we are transitioning from the update dispatcher to the mount\n\t\t// dispatcher, then this component is using the `use` hook and is resuming\n\t\t// from a mount. We should not re-invoke our hooks in this situation since\n\t\t// we are not entering a new component render, but instead continuing a\n\t\t// previous render.\n\t\t//\n\t\t// ## Other transitions\n\t\t//\n\t\t// For example, Mount -> Mount, Update -> Update, Mount -> Update, any\n\t\t// transition in and out of invalid dispatchers.\n\t\t//\n\t\t// There is no known transition for the following transitions so we default\n\t\t// to not triggering a re-enter of the component.\n\t\t// - HooksDispatcherOnMount  -> HooksDispatcherOnMount\n\t\t// - HooksDispatcherOnMount  -> HooksDispatcherOnUpdate\n\t\t// - HooksDispatcherOnUpdate -> HooksDispatcherOnUpdate\n\t\treturn false;\n\t}\n}\n\n/**\n * We are exiting a component render if the current dispatcher is a valid\n * dispatcher and the next dispatcher is the ContextOnlyDispatcher.\n */\nfunction isExitingComponentRender(\n\tcurrentDispatcherType: DispatcherType,\n\tnextDispatcherType: DispatcherType\n): boolean {\n\treturn Boolean(\n\t\tcurrentDispatcherType & BrowserClientDispatcherType &&\n\t\tnextDispatcherType & ContextOnlyDispatcherType\n\t);\n}\n\ninterface JsxRuntimeModule {\n\tjsx?(type: any, ...rest: any[]): unknown;\n\tjsxs?(type: any, ...rest: any[]): unknown;\n\tjsxDEV?(type: any, ...rest: any[]): unknown;\n}\n\nexport function installJSXHooks() {\n\tconst JsxPro: JsxRuntimeModule = jsxRuntime;\n\tconst JsxDev: JsxRuntimeModule = jsxRuntimeDev;\n\n\t/**\n\t * createElement _may_ be called by jsx runtime as a fallback in certain cases,\n\t * so we need to wrap it regardless.\n\t *\n\t * The jsx exports depend on the `NODE_ENV` var to ensure the users' bundler doesn't\n\t * include both, so one of them will be set with `undefined` values.\n\t */\n\tReact.createElement = wrapJsx(React.createElement);\n\tJsxDev.jsx && /*   */ (JsxDev.jsx = wrapJsx(JsxDev.jsx));\n\tJsxPro.jsx && /*   */ (JsxPro.jsx = wrapJsx(JsxPro.jsx));\n\tJsxDev.jsxs && /*  */ (JsxDev.jsxs = wrapJsx(JsxDev.jsxs));\n\tJsxPro.jsxs && /*  */ (JsxPro.jsxs = wrapJsx(JsxPro.jsxs));\n\tJsxDev.jsxDEV && /**/ (JsxDev.jsxDEV = wrapJsx(JsxDev.jsxDEV));\n\tJsxPro.jsxDEV && /**/ (JsxPro.jsxDEV = wrapJsx(JsxPro.jsxDEV));\n}\n\nexport function installAutoSignalTracking() {\n\tinstallCurrentDispatcherHook();\n\tinstallJSXHooks();\n}\n","import {\n\tsignal,\n\tcomputed,\n\tbatch,\n\teffect,\n\tSignal,\n\ttype ReadonlySignal,\n\tuntracked,\n} from \"@preact/signals-core\";\nimport type { ReactElement } from \"react\";\nimport { useSignal, useComputed, useSignalEffect } from \"../runtime\";\nimport { installAutoSignalTracking } from \"../runtime/src/auto\";\n\nexport {\n\tsignal,\n\tcomputed,\n\tbatch,\n\teffect,\n\tSignal,\n\ttype ReadonlySignal,\n\tuseSignal,\n\tuseComputed,\n\tuseSignalEffect,\n\tuntracked,\n};\n\ndeclare module \"@preact/signals-core\" {\n\t// @ts-ignore internal Signal is viewed as function\n\t// eslint-disable-next-line @typescript-eslint/no-empty-interface\n\tinterface Signal extends ReactElement {}\n}\n\ninstallAutoSignalTracking();\n"],"names":["ReactElemType","Symbol","wrapJsx","jsx","type","props","i","v","Signal","value","call","apply","concat","slice","arguments","finishUpdate","symDispose","dispose","setCurrentStore","store","effect","_start","finalCleanup","clearCurrentStore","_queueMicroTask","Promise","prototype","then","bind","resolve","Object","defineProperties","$$typeof","configurable","_ref2","data","get","this","ref","lock","currentDispatcher","dispatcherTypeCache","Map","getDispatcherType","dispatcher","cached","undefined","useCallbackImpl","useCallback","toString","useReducer","useEffect","useImperativeHandle","test","useReducerImpl","set","defineProperty","ReactInternals","ReactCurrentDispatcher","nextDispatcher","currentDispatcherType","nextDispatcherType","MountDispatcherType","isEnteringComponentRender","storeRef","useRef","current","_ref","effectInstance","onChangeNotifyReact","version","unsubscribe","_callback","subscribe","onStoreChange","getSnapshot","f","createEffectStore","useSyncExternalStore","useSignals","Boolean","isExitingComponentRender","_store","JsxPro","jsxRuntime","JsxDev","jsxRuntimeDev","React","createElement","jsxs","jsxDEV","installJSXHooks","installAutoSignalTracking","useComputed","useSignal","useSignalEffect"],"mappings":"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"}